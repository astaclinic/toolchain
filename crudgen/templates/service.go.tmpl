package {{.LowerName}}

import (
	"context"
	"errors"

	"{{.Package}}/{{.OutDir}}/{{.LowerName}}/dto"
	"{{.Package}}/{{.OutDir}}/{{.LowerName}}/entities"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type {{.CapitalizedName}}Service struct {
	db *gorm.DB
}

func New{{.CapitalizedName}}Service(db *gorm.DB) *{{.CapitalizedName}}Service {
	return &{{.CapitalizedName}}Service{db: db}
}

func (s *{{.CapitalizedName}}Service) Create(ctx context.Context, create{{.CapitalizedName}}Input dto.Create{{.CapitalizedName}}Input) (*dto.{{.CapitalizedName}}, error) {
	{{.Name}} := create{{.CapitalizedName}}Input.ToEntity()
	res := s.db.WithContext(ctx).Create({{.Name}})
	if res.Error != nil {
		return nil, res.Error
	}
	return dto.FromEntity({{.Name}}), nil
}

func (s *{{.CapitalizedName}}Service) GetAll(ctx context.Context) ([]*dto.{{.CapitalizedName}}, error) {
	var {{.PluralName}} []*entities.{{.CapitalizedName}}
	res := s.db.WithContext(ctx).Find(&{{.PluralName}})
	if res.Error != nil {
		return nil, res.Error
	}
	var {{.PluralName}}Dto = make([]*dto.{{.CapitalizedName}}, len({{.PluralName}}))
	for i, {{.Name}} := range {{.PluralName}} {
		{{.PluralName}}Dto[i] = dto.FromEntity({{.Name}})
	}
	return {{.PluralName}}Dto, nil
}

func (s *{{.CapitalizedName}}Service) GetOne(ctx context.Context, id uint) (*dto.{{.CapitalizedName}}, error) {
	var {{.Name}} entities.{{.CapitalizedName}}
	res := s.db.WithContext(ctx).First(&{{.Name}}, id)
	if res.Error != nil {
		if errors.Is(res.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, res.Error
	}
	return dto.FromEntity(&{{.Name}}), nil
}

func (s *{{.CapitalizedName}}Service) Update(ctx context.Context, input *dto.Update{{.CapitalizedName}}Input) (*dto.{{.CapitalizedName}}, error) {
	{{.Name}} := input.ToEntity()
	updated{{.CapitalizedName}} := &entities.{{.CapitalizedName}}{Model: gorm.Model{ID: input.ID}}
	res := s.db.WithContext(ctx).Model(&updated{{.CapitalizedName}}).Clauses(clause.Returning{}).Updates({{.Name}})
	if res.Error != nil {
		return nil, res.Error
	}
	if res.RowsAffected == 0 {
		return nil, nil
	}
	return dto.FromEntity(updated{{.CapitalizedName}}), nil
}

func (s *{{.CapitalizedName}}Service) Remove(ctx context.Context, id uint) (*dto.{{.CapitalizedName}}, error) {
	var {{.Name}} entities.{{.CapitalizedName}}
	res := s.db.WithContext(ctx).Clauses(clause.Returning{}).Delete(&{{.Name}}, id)
	if res.Error != nil {
		return nil, res.Error
	}
	if res.RowsAffected == 0 {
		return nil, nil
	}
	return dto.FromEntity(&{{.Name}}), nil
}
